{"mappings":"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","sources":["experiments-static/snake/js/game/GameState.js"],"sourcesContent":["window.GameState = function GameState (spec) {\n  var that = {};\n\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random\n  function getRandomInt(min, max) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min)) + min; //The maximum is exclusive and the minimum is inclusive\n  }\n\n  that.didEat = false;\n\n  // spec.gameOver(that);\n  /**\n   * GameState private variables with getters and setters\n   */\n  (()=>{\n    var _points = 0;\n    Object.defineProperty(that, 'points', {\n      get () {\n        return that.snake.length;\n      },\n    });\n    var _paused = false;\n    Object.defineProperty(that, 'paused', {\n      get () {\n        return _paused;\n      },\n      set (val) {\n        _paused = !!val\n      }\n    });\n    var _ready = false;\n    Object.defineProperty(that, 'ready', {\n      get () {\n        if(that.paused) {\n          return false;\n        } else {\n          return _ready;\n        }\n      },\n      set (val) {\n        _ready = !!val;\n      }\n    });\n  })();\n\n  const countDownTime = 3;\n  that.countdown = countDownTime;\n\n  that.ready = true;\n\n  var totalTime = 0;\n  var lastMove = 0;\n  that.update = function (elapsed) {\n    if(!that.ready) {\n      return;\n    }\n    totalTime += elapsed;\n    if(that.countdown > 0) {\n      that.countdown = countDownTime - Math.floor(totalTime / 1000);\n      \n      if(that.countDown <= 0) {\n        that.ready = true;\n      }\n    }\n    if(!that.snake.moving) {\n      lastMove = totalTime;\n    }\n    that.didEat = false;\n    const msPerMove = 150;\n    var elapsedSinceLastMove = totalTime - lastMove;\n    if(elapsedSinceLastMove > 150) {\n      that.snake.makeMoves(Math.floor(elapsedSinceLastMove/150));\n      lastMove = totalTime;\n    }\n  }\n\n  function Snake () {\n    var moving = false;\n    var dirs = {\n      'up': {\n        'opposite': 'down',\n        vector: {\n          xDelta: 0,\n          yDelta: -1,\n        }\n      },\n      'down': {\n        'opposite': 'up',\n        vector: {\n          xDelta: 0,\n          yDelta: 1,\n        }\n      },\n      'right': {\n        'opposite': 'left',\n        vector: {\n          xDelta: 1,\n          yDelta: 0,\n        }\n      },\n      'left': {\n        'opposite': 'right',\n        vector: {\n          xDelta: -1,\n          yDelta: 0,\n        }\n      },\n    }\n    var _dir = null;\n    var _parts = [\n      {\n        x: 24, \n        y: 24\n      },\n    ];\n    var pendingTail = 0;\n    var snake = {\n      get moving () {\n        return moving;\n      },\n      set moving (value) {\n        moving = value;\n      },\n      set dir (val) {\n        if(['up', 'left', 'down', 'right'].indexOf(val) > -1 && (!snake.dir || snake.dir.opposite != val)) {\n          if(!moving) moving = true;\n          _dir = val;\n        }\n      },\n      get dir () {\n        return _dir && dirs[_dir];\n      },\n      dirs: {\n        up: 'up',\n        down: 'down',\n        left: 'left',\n        right: 'right',\n      },\n      get parts () {\n        return _parts;\n      },\n      makeMoves (moveNumber) {\n        for(var i = 0; i < moveNumber; ++i) {\n          // add to the front\n          var newPart = {\n            x: _parts[0].x + snake.dir.vector.xDelta,\n            y: _parts[0].y + snake.dir.vector.yDelta,\n          };\n          if(that.obstacles.intersects(newPart) || snake.intersects(newPart) || newPart.x <= 0 || newPart.x >= 49 || newPart.y <= 0 || newPart.y >= 49) {\n            that.gameOver = true;\n            spec.gameOver(that);\n          };\n          _parts.unshift(newPart);\n          // remove from back\n          if(pendingTail > 0) {\n            pendingTail--;\n          } else {\n            _parts.pop();\n          }\n\n          if(that.food.intersects(newPart)) {\n            pendingTail += 3;\n            // get new food\n            that.food = Food();\n            that.didEat = true;\n          }\n        }\n      },\n      get length () {\n        return snake.parts.length + pendingTail;\n      },\n      intersects (item) {\n        for(const part of snake) {\n          if(part.x == item.x && part.y == item.y) {\n            return true;\n          }\n        }\n        return false;\n      },\n      *[Symbol.iterator] () {\n        yield* snake.parts\n      }\n    };\n\n    snake.moving = false;\n\n    return snake;\n  }\n\n  function Obstacles () {\n    const numObstacles = 15;\n\n    var obstacles = [];\n    for(var i = 0; i < numObstacles; ++i) {\n      obstacles.push(Obstacle());\n    }\n\n    function Obstacle () {\n      var obstacle = {\n        x: getRandomInt(1, 49),\n        y: getRandomInt(1, 49),\n        intersectsSnake () {\n          return that.snake.intersects(obstacle);\n        },\n        intersectsObstacle () {\n          for(var obs of obstacles) {\n            if(obs && obs.x == obstacle.x && obs.y === obstacle.y) {\n              return true\n            }\n          }\n          return false;\n        },\n      };\n      if(obstacle.intersectsSnake() || obstacle.intersectsObstacle()) {\n        return Obstacle();\n      } else {\n        return obstacle;\n      }\n    }\n    var obstacless = {\n      obstacles,\n      *[Symbol.iterator] () {\n        yield* obstacles;\n      },\n      intersects (item) {\n        for(var obstacle of obstacless) {\n          if(obstacle.x === item.x && obstacle.y === item.y) {\n            return true;\n          }\n        }\n        return false;\n      },\n    };\n    return obstacless\n  }\n\n  function Food () {\n    var food = {\n      x: getRandomInt(1, 49),\n      y: getRandomInt(1, 49),\n      intersects (item) {\n        if(item.x === food.x && food.y === item.y) {\n          return true;\n        }\n        return false;\n      }\n    }\n    if(that.obstacles.intersects(food) || that.snake.intersects(food)) {\n      // get a different coord\n      return Food();\n    } else {\n      return food;\n    }\n  }\n\n  that.snake = Snake();\n  that.obstacles = Obstacles();\n  that.food = Food();\n  \n  return that;\n};\n"],"names":["window","GameState","spec","that","getRandomInt","min","max","Math","ceil","floor","random","didEat","Object","defineProperty","get","snake","length","_paused","set","val1","_ready","paused","countdown","ready","moving","dirs","_dir","_parts","pendingTail","totalTime","lastMove","Food","food","x","y","intersects","item","obstacles","update","elapsed","countDown","elapsedSinceLastMove","makeMoves","up","opposite","vector","xDelta","yDelta","down","right","left","value","dir","val","indexOf","parts","moveNumber","i","newPart","gameOver","unshift","pop","part","Symbol","iterator","push","Obstacle","obstacle","intersectsSnake","intersectsObstacle","obs","obstacless","Obstacles"],"version":3,"file":"index.901d92a5.js.map"}