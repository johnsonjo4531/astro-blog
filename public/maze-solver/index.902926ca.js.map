{"mappings":"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","sources":["experiments-static/maze-solver/modules/GameState.js"],"sourcesContent":["window.GameState = function (maze,\n  {\n    onGameOver = (gameState) => {},\n    onScoreUpdate = (score) => {},\n    onScoreHide = () => {},\n    onTimeUpdate = (time) => {},\n  }) {\n\n    var that = {};\n\n  var n = maze.matrix.length;\n  var start = maze.matrix[0][0];\n  var finish = maze.matrix[n-1][n-1];\n  var breadCrumbsOn = true;\n  var shortestPathOn = false;\n  var hintOn = false;\n  var scoreOn = true;\n\n  var shortestPath = getPath(start, finish);\n  \n  var isDirty = true;\n\n  var time = 0;\n\n  var enabled = true;\n  var that = {\n    get scoreOn () {\n      return scoreOn;\n    },\n    get hintOn () {\n      return hintOn;\n    },\n    get shortestPathOn () {\n      return shortestPathOn;\n    },\n    get breadCrumbsOn () {\n      return breadCrumbsOn;\n    },\n    get player () {\n      return player;\n    },\n    get shortestPath () {\n      return shortestPath;\n    },\n    get isDirty () {\n      return isDirty;\n    },\n    set isDirty (val) {\n      // cast value to boolean\n      isDirty = !!val;\n    },\n    doCommand: doCommand,\n    get start () {\n      return start;\n    },\n    get finish () {\n      return finish;\n    },\n    get player () {\n      return player;\n    },\n    get maze () {\n      return maze;\n    },\n    get time () {\n      return time;\n    },\n    get enabled () {\n      return enabled;\n    },\n    set enabled (val) {\n      // cast to bool\n      enabled = !!val;\n    },\n    set time (val) {\n      time = val\n      onTimeUpdate(that);\n    },\n    get secondTime () {\n      return that.time / 10**3;\n    },\n    get timeString () {\n      var padZeros = (str) => (\"00\" + str).split(\"\").slice(-2).join(\"\");\n      var seconds = Math.floor(that.secondTime % 60);\n      var minutes = Math.floor(that.secondTime / 60);\n      return `${minutes}:${padZeros(seconds)}`;\n    }\n  };\n\n  // closure to keep player variables hidden\n  var player = (function (gameState) {\n    var playerPosition = start;\n    playerPosition.visited = true;\n\t\tvar wasOffCourse = false;\n\t\tlet score = 0;\n\n    var that = {\n      get position () {\n        return playerPosition;\n      },\n      set position (newPosition) {\n        // only allow non-null linked positions\n        var linkedNodes = Object.values(playerPosition.linked);\n        var truthyLinkedNodes = linkedNodes.filter(x=>!!x)\n        var linkedPositions = new Set(truthyLinkedNodes);\n        if(linkedPositions.has(newPosition)) {\n          playerPosition = newPosition;\n          if(!playerPosition.visited) {\n            if(playerPosition == shortestPath[1]) {\n              that.score += 5;\n            } else if(wasOffCourse) {\n              that.score -= 2;\n            } else {\n              that.score -= 1;\n            }\n          }\n          playerPosition.visited = true;\n          if(playerPosition == shortestPath[1]) {\n            wasOffCourse = false;\n            shortestPath.shift();\n            if(shortestPath.length === 1) {\n              gameState.enabled = false;\n              onGameOver(gameState);\n            }\n          } else {\n            shortestPath.unshift(playerPosition);\n            wasOffCourse = true;\n          }\n        }\n      },\n      get score () {\n        return score;\n      },\n      // we're allowing negative scores\n      set score (newScore) {\n        newScore = Number(newScore);\n        if(!Number.isNaN(newScore)) {\n          score = newScore;\n          if(scoreOn) {\n            onScoreUpdate(score);\n          }\n        }\n      },\n    }\n\n    that.score = 0;\n\n    return that;\n  })(that);\n\n\n  function movePlayer (dir) {\n\n  }\n\n  // since it's a perfect maze we're doing a modified depth first search\n  function getPath (start, finish, path=[], prev=null) {\n    path.push(start);\n    if(start === finish) {\n      return path;\n    }\n    for(var node of Object.values(start.linked)) {\n      if(node && node !== prev) {\n        var newPath = getPath(node, finish, [...path], start);\n        if(newPath) {\n          return newPath;\n        }\n      }\n    }\n    return false;\n  }\n\n  var commands = {\n    move (dir) {\n      var lastPosition = player.position;\n      player.position = player.position.linked[dir];\n      if(player.position !== lastPosition) {\n        that.isDirty = true;\n      }\n    },\n    breadCrumbsToggle () {\n      breadCrumbsOn = !breadCrumbsOn;\n      that.isDirty = true;\n    },\n    shortestPathToggle () {\n      shortestPathOn = !shortestPathOn;\n      that.isDirty = true;\n    },\n    hintToggle () {\n      hintOn = !hintOn;\n      that.isDirty = true;\n    },\n    scoreToggle () {\n      scoreOn = !scoreOn;\n      if(!scoreOn) {\n        onScoreHide();\n      } else {\n        onScoreUpdate(player.score);\n      }\n    }\n  };\n  function doCommand (cmd, ...args) {\n    commands[cmd](...args);\n  }\n  \n  return that;\n};\n"],"names":["window","GameState","maze","onGameOver","gameState","onScoreUpdate","score","onScoreHide","onTimeUpdate","time","that","n","matrix","length","start","finish","breadCrumbsOn","shortestPathOn","hintOn","scoreOn","shortestPath","getPath","path","prev","push","node","Object","values","linked","newPath","isDirty","enabled","player","playerPosition","visited","wasOffCourse","position","newPosition","truthyLinkedNodes","filter","x","Set","has","shift","unshift","newScore","Number","isNaN","val","doCommand","cmd","args","commands","secondTime","timeString","str","seconds","Math","floor","split","slice","join","move","dir","lastPosition","breadCrumbsToggle","shortestPathToggle","hintToggle","scoreToggle"],"version":3,"file":"index.902926ca.js.map"}