{"mappings":"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","sources":["experiments-static/brick-breaker/modules/ParticleSystem.js"],"sourcesContent":["window.ParticleSystem = (function ParticleSystem() {\n\tvar particleSystems = new Set();\n\tfunction create (spec, graphics) {\n\t\tlet that = {};\n\t\tlet particles = [];\n\t\tthat.render = function() {};\n\t\t// if(spec.image) {\n\t\t// \tlet image = new Image();\n\t\t// \timage.onload = function () {\n\t\t// \t\tthat.render = function() {\n\t\t// \t\t\tfor (let particle = 0; particle < particles.length; particle++) {\n\t\t// \t\t\t\tif (particles[particle].alive >= 100) {\n\t\t// \t\t\t\t\t//graphics.drawRectangle(\n\t\t// \t\t\t\t\t\t// particles[particle].position,\n\t\t// \t\t\t\t\t\t// particles[particle].size,\n\t\t// \t\t\t\t\t\t// particles[particle].rotation,\n\t\t// \t\t\t\t\t\t// particles[particle].fill,\n\t\t// \t\t\t\t\t\t// particles[particle].stroke);\n\t\t// \t\t\t\t\tgraphics.drawImage(\n\t\t// \t\t\t\t\t\tparticles[particle].position,\n\t\t// \t\t\t\t\t\tparticles[particle].size,\n\t\t// \t\t\t\t\t\tparticles[particle].rotation,\n\t\t// \t\t\t\t\t\timage);\n\t\t// \t\t\t\t}\n\t\t// \t\t\t}\n\t\t// \t\t};\t\n\t\t// \t};\n\t\t// \timage.src = spec.image;\n\t\t// } else {\n\t\tvar totalTimeElapsed = 0;\n\t\tthat.render = function() {\n\t\t\tfor (let particle = 0; particle < particles.length; particle++) {\n\t\t\t\tgraphics.renderCircle({\n\t\t\t\t\tx: particles[particle].position.x,\n\t\t\t\t\ty: particles[particle].position.y,\n\t\t\t\t\tradius: Math.max(0, particles[particle].size / 2),\n\t\t\t\t\tcolor: spec.color,\n\t\t\t\t\topacity: (spec.opacity * (1 - totalTimeElapsed/spec.systemLifetime)),\n\t\t\t\t})\n\t\t\t}\n\t\t};\n\t\t// }\n\n\t\tvar cornerPoints = [\n\t\t\t{\n\t\t\t\tx: spec.position.xMin,\n\t\t\t\ty: spec.position.yMin,\n\t\t\t},\n\t\t\t{\n\t\t\t\tx: spec.position.xMax,\n\t\t\t\ty: spec.position.yMin,\n\t\t\t},\n\t\t\t{\n\t\t\t\tx: spec.position.xMin,\n\t\t\t\ty: spec.position.yMax,\n\t\t\t},\n\t\t\t{\n\t\t\t\tx: spec.position.xMax,\n\t\t\t\ty: spec.position.yMax,\n\t\t\t}\n\t\t];\n\t\tvar highSpeed = spec.speed.mean + spec.speed.stdev;\n\t\tvar longLife  = spec.lifetime.mean + spec.lifetime.stdev;\n\t\tvar largeLifeDistance = highSpeed * longLife;\n\t\tvar largeStartDistance = Math.max(...cornerPoints.map(x => distBetweenPoints(x, spec.position)));\n\t\tvar largeDistance = largeLifeDistance + largeStartDistance;\n\t\tfunction setSpeedByCenterOffset (particle) {\n\t\t\tparticle.speed = Math.max(0, particle.maxSpeed * (1 - distBetweenPoints(particle.position, spec.position)/largeDistance));\n\t\t}\n\n\t\tfunction distBetweenPoints (a, b) {\n\t\t\treturn Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);\n\t\t}\n\n\t\tvar first = true;\n\t\tthat.update = function(elapsedTime) {\n\t\t\ttotalTimeElapsed += elapsedTime;\n\t\t\tif(totalTimeElapsed > spec.systemLifetime) {\n\t\t\t\tparticleSystems.delete(that);\n\t\t\t}\n\t\t\tlet keepMe = [];\n\t\t\tvar particlesThisTime = spec.particlesPerUpdate\n\n\t\t\tfor (let particle = 0; particle < particles.length; particle++) {\n\t\t\t\tparticles[particle].alive += elapsedTime;\n\t\t\t\tparticles[particle].position.x += (elapsedTime * particles[particle].speed * particles[particle].direction.x);\n\t\t\t\tparticles[particle].position.y += (elapsedTime * particles[particle].speed * particles[particle].direction.y);\n\t\t\t\tparticles[particle].rotation += particles[particle].speed / .5;\n\n\t\t\t\tsetSpeedByCenterOffset(particles[particle]);\n\t\t\t\tif (particles[particle].alive <= particles[particle].lifetime) {\n\t\t\t\t\tkeepMe.push(particles[particle]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let particle = 0; particle < spec.particlesPerUpdate; particle++) {\n\t\t\t\tlet maxSpeed = Random.nextGaussian( spec.speed.mean, spec.speed.stdev );\n\t\t\t\tlet p = {\n\t\t\t\t\tposition: { x: Random.nextRange(spec.position.xMin, spec.position.xMax), y: Random.nextRange(spec.position.yMin, spec.position.yMax) },\n\t\t\t\t\tdirection: Random.nextCircleVector(),\n\t\t\t\t\tmaxSpeed,\n\t\t\t\t\tspeed: maxSpeed,\t// pixels per millisecond\n\t\t\t\t\trotation: 0,\n\t\t\t\t\tlifetime: Random.nextGaussian(spec.lifetime.mean, spec.lifetime.stdev),\t// milliseconds\n\t\t\t\t\talive: 0,\n\t\t\t\t\tsize: Random.nextGaussian(spec.size.mean, spec.size.stdev),\n\t\t\t\t\tfill: spec.fill,\n\t\t\t\t\tstroke: 'rgb(0, 0, 0)'\n\t\t\t\t};\n\t\t\t\tsetSpeedByCenterOffset(p);\n\t\t\t\tkeepMe.push(p);\n\t\t\t}\n\t\t\tfirst = false;\n\t\t\tparticles = keepMe;\n\t\t};\n\n\t\tparticleSystems.add(that);\n\t}\n\n\tfunction update (elapsed) {\n\t\tfor(const p of particleSystems) {\n\t\t\tp.update(elapsed);\n\t\t}\n\t}\n\n\tfunction render (elapsed) {\n\t\tfor(const p of particleSystems) {\n\t\t\tp.render(elapsed);\n\t\t}\n\t}\n\n\treturn {\n\t\tcreate,\n\t\tupdate,\n\t\trender,\n\t}\n})();\n"],"names":["particleSystems","window","ParticleSystem","Set","spec","graphics","that","particles","render","totalTimeElapsed","particle","length","renderCircle","x","position","y","radius","Math","max","size","color","opacity","systemLifetime","cornerPoints","xMin","yMin","xMax","yMax","largeDistance","speed","mean","stdev","lifetime","map","distBetweenPoints","setSpeedByCenterOffset","maxSpeed","a","b","sqrt","update","elapsedTime","delete","keepMe","particlesPerUpdate","alive","direction","rotation","push","Random","nextGaussian","p","nextRange","nextCircleVector","fill","stroke","add","elapsed"],"version":3,"file":"index.49d788b7.js.map"}