{"mappings":"AAAAA,OAAOC,SAAW,WAKhB,SAASC,EAAOC,EAAGC,GAKjB,MAJY,CACVC,EAAGF,EACHG,EAAGF,EAGP,CAEA,SAASG,EAA6BC,EAAKC,GACzC,IAAIC,EAAQC,EAAKH,EAAII,EAAGJ,EAAIK,GAAGC,iBAAiBL,GAC5CM,EAAOC,KAAKC,IAAIT,EAAII,EAAEP,EAAGG,EAAIK,EAAER,GAC/Ba,EAAOF,KAAKG,IAAIX,EAAII,EAAEP,EAAGG,EAAIK,EAAER,GAC/Be,EAAOJ,KAAKC,IAAIT,EAAII,EAAEN,EAAGE,EAAIK,EAAEP,GAC/Be,EAAOL,KAAKG,IAAIX,EAAII,EAAEN,EAAGE,EAAIK,EAAEP,GACnC,SAAGI,GAASA,EAAML,GAAKU,GAAQL,EAAML,GAAKa,GACrCR,EAAMJ,GAAKc,GAAQV,EAAMJ,GAAKe,IAC1BX,CAGX,CAEA,SAASY,EAAaC,EAASC,GAC7B,MAAMC,EAAU,CAEdb,EAAGW,EAEHV,EAAGW,EACHV,iBAAkBL,GACTF,EAA4BkB,EAAShB,GAK1CiB,YACF,IAAIC,EAASF,EAAQZ,EAAEP,EAAImB,EAAQb,EAAEN,EACjCsB,EAASH,EAAQZ,EAAER,EAAIoB,EAAQb,EAAEP,EACrC,OAAOW,KAAKa,MAAMF,EAAQC,EAC5B,EAEAE,wBAAyBC,GACvB,MAAOC,EAAMC,GAAQ,CAACR,EAAQb,EAAEP,EAAGoB,EAAQb,EAAEN,IACtC4B,EAAMC,GAAQ,CAACV,EAAQZ,EAAER,EAAGoB,EAAQZ,EAAEP,IACtC8B,EAAMC,GAAQ,CAACN,EAASnB,EAAEP,EAAG0B,EAASnB,EAAEN,IACxCgC,EAAMC,GAAQ,CAACR,EAASlB,EAAER,EAAG0B,EAASlB,EAAEP,GAC/C,IAAIkC,EAAMC,EAAMC,EAAMC,EAIlBC,EAAGC,EAIP,GAPAL,EAAON,EAAOF,EAAUS,EAAON,EAAOF,EACtCS,EAAOJ,EAAOF,EAAUO,EAAOJ,EAAOF,EAGtCO,IAAMH,GAAQT,EAAOI,GAAQI,GAAQP,EAAOI,MAAWK,EAAOD,EAAOD,EAAOG,GAC5EE,GAAMH,GAAQT,EAAOI,GAAQM,GAAQX,EAAOI,MAAWM,EAAOD,EAAOD,EAAOG,GAExEC,GAAK,GAAKA,GAAK,GAAKC,GAAK,GAAKA,GAAK,EACvC,CAGE,OAAO3C,EAAM,CACXG,EAHU2B,EAAQa,EAAIL,EAItBlC,EAHU2B,EAAQY,EAAIJ,GAK1B,CAGA,OAAO,CACT,GAGF,OAAOhB,CACT,CAuEA,SAASd,EAAMY,EAASC,GAEtB,MAAMsB,EAAO,CACXlC,EAAGW,EACHV,EAAGW,EACCuB,QACF,OAAOD,EAAKjC,EAAEP,EAAIwC,EAAKlC,EAAEN,CAC3B,EACI0C,QACF,OAAOF,EAAKlC,EAAEP,EAAIyC,EAAKjC,EAAER,CAC3B,EACI4C,QACF,OAAOH,EAAKC,EAAID,EAAKlC,EAAEP,EAAIyC,EAAKE,EAAIF,EAAKlC,EAAEN,CAC7C,EAMAQ,iBAAkBL,GAChB,MAAOyC,EAAIC,EAAIC,GAAM,CAACN,EAAKC,EAAGD,EAAKE,EAAGF,EAAKG,IACpCI,EAAIC,EAAIC,GAAM,CAAC9C,EAAKsC,EAAGtC,EAAKuC,EAAGvC,EAAKwC,GACrCO,EAAMN,EAAGI,EAAKD,EAAGF,EACvB,OAAU,GAAPK,EAEQ,KAEAtD,GAAOoD,EAAGF,EAAKD,EAAGI,GAAIC,GAC1BN,EAAGK,EAAKF,EAAGD,GAAII,EAExB,EACA1B,wBAAyBL,GAChBlB,EAA4BkB,EAASqB,GAE9CW,eAAgBC,GACd,IAAIC,EAAK,KACLC,EAAK,KACLC,EAhEV,SAAiBC,GACf,IAAIC,EAAUD,EAAME,OAGpB,KAAOD,EAAU,GAAG,CAElB,IAAIE,EAAQjD,KAAKkD,MAAMlD,KAAKmD,SAAWJ,GAGvCA,IAGA,IAAIK,EAAON,EAAMC,GACjBD,EAAMC,GAAWD,EAAMG,GACvBH,EAAMG,GAASG,CACjB,CAEA,OAAON,CACT,CA8CqBO,CAAQ,CAACX,EAAKY,aAAcZ,EAAKa,cAAeb,EAAKc,eAAgBd,EAAKe,cACzF,IAAI,IAAIjE,KAAOqD,EAAU,CACvB,IAAIa,EAAe5B,EAAKhB,wBAAwBtB,GAChD,GAAGkE,EAAc,CACf,GAAGf,IAAOC,EAAI,CACZA,EAAKc,EACL,KACF,CACIf,IACFA,EAAKe,EAET,CACF,CACA,OAAGf,GAAMC,EACAtC,EAAYqC,EAAIC,GAGlB,IACT,GAEF,OAAOd,CACT,CA2BA,SAAS6B,EAAWC,GAElB,IAAIC,EAAS,CACPxE,QACF,OAAOyC,EAAKzC,EAAIyC,EAAKgC,MAAQ,CAC/B,EACIxE,QACF,OAAOwC,EAAKxC,EAAIwC,EAAKiC,OAAS,CAChC,GAEEjC,EAAO,CACTiC,OAAQH,EAAKG,OACbD,MAAOF,EAAKE,MACZzE,EAAGuE,EAAKvE,EACRC,EAAGsE,EAAKtE,EACJ0E,UACF,OAAOlC,EAAKxC,CACd,EACI2E,WACF,OAAOnC,EAAKzC,CACd,EACI6E,YACF,OAAOpC,EAAKzC,EAAIyC,EAAKgC,KACvB,EACIK,aACF,OAAOrC,EAAKxC,EAAIwC,EAAKiC,MACvB,EACIF,aACF,OAAOA,CACT,EAIIP,mBAGF,OAAOhD,EAFEpB,EAAM4C,EAAKmC,KAAMnC,EAAKkC,KACtB9E,EAAM4C,EAAKmC,KAAMnC,EAAKqC,QAEjC,EACIZ,oBAGF,OAAOjD,EAFEpB,EAAM4C,EAAKoC,MAAOpC,EAAKkC,KACvB9E,EAAM4C,EAAKoC,MAAOpC,EAAKqC,QAElC,EACIX,qBAGF,OAAOlD,EAFEpB,EAAM4C,EAAKmC,KAAMnC,EAAKqC,QACtBjF,EAAM4C,EAAKoC,MAAOpC,EAAKqC,QAElC,EACIV,kBAGF,OAAOnD,EAFEpB,EAAM4C,EAAKmC,KAAMnC,EAAKkC,KACtB9E,EAAM4C,EAAKoC,MAAOpC,EAAKkC,KAElC,EACAI,cAAeC,GACVvC,EAAKmC,MAAQI,EAAMhF,GAAKyC,EAAKoC,OAASG,EAAMhF,GAAKyC,EAAKkC,KAAOK,EAAM/E,GAAKwC,EAAKqC,QAAUE,EAAM/E,EAKlGgF,eAAgBtC,GAEd,MAAMD,EAAID,EACJyC,EAAI,IAAOxC,EAAE+B,MAAQ9B,EAAE8B,OACvBU,EAAI,IAAOzC,EAAEgC,OAAS/B,EAAE+B,QACxBU,EAAK1C,EAAE8B,OAAOxE,EAAI2C,EAAE6B,OAAOxE,EAC3BqF,EAAK3C,EAAE8B,OAAOvE,EAAI0C,EAAE6B,OAAOvE,EAEjC,GAAIU,KAAK2E,IAAIF,IAAOF,GAAKvE,KAAK2E,IAAID,IAAOF,EACzC,CAEE,MAAMI,EAAKL,EAAIG,EACTG,EAAKL,EAAIC,EAEf,OAAIG,EAAKC,EACHD,GAAMC,EAEDlB,EAAUmB,aAAaX,OAGrBR,EAAUmB,aAAab,KAG9BW,GAAMC,EAEDlB,EAAUmB,aAAaZ,MAGvBP,EAAUmB,aAAad,GAGpC,CACE,OAAO,CAEX,GAMF,OAAOlC,CACT,CAQA,OAPA6B,EAAUmB,aAAe,CACvBb,KAAM,OACNC,MAAO,QACPC,OAAQ,SACRH,IAAK,OAGA,C,UACLL,E,OA/HF,SAAiBC,GACf,IAAI9B,EAAO,CACTiD,OAAQnB,EAAKmB,OACb1F,EAAGuE,EAAKvE,EACRC,EAAGsE,EAAKtE,EACJ0F,mBACF,OAAOrB,EAAU,CACfG,MAAqB,EAAdhC,EAAKiD,OACZhB,OAAsB,EAAdjC,EAAKiD,OACb1F,EAAGyC,EAAKzC,EAAIyC,EAAKiD,OACjBzF,EAAGwC,EAAKxC,EAAIwC,EAAKiD,QAErB,GAGF,OAAOjD,CACT,E,YAiHExB,E,MACApB,E,KACAS,EAEJ,CAxVkB","sources":["experiments-static/snake/js/lib/Geometry.js"],"sourcesContent":["window.Geometry = (function () {\n  function pointInPolygon () {\n\n  }\n\n  function Point (x, y) {\n    var point = {\n      x: x,\n      y: y,\n    };\n    return point;\n  }\n\n  function lineSegmentLineIntersection (seg, line) {\n    var inter = Line(seg.a, seg.b).lineIntersection(line);\n    var minX = Math.min(seg.a.x, seg.b.x);\n    var maxX = Math.max(seg.a.x, seg.b.x);\n    var minY = Math.min(seg.a.y, seg.b.y);\n    var maxY = Math.max(seg.a.y, seg.b.y);\n    if(inter && inter.x >= minX && inter.x <= maxX\n      && inter.y >= minY && inter.y <= maxY) {\n      return inter;\n    }\n    return false;\n  }\n\n  function LineSegment (point_a, point_b) {\n    const lineSeg = {\n      // first endpoint a\n      a: point_a,\n      // second endpoint b\n      b: point_b,\n      lineIntersection (line) {\n        return lineSegmentLineIntersection(lineSeg, line);\n      },\n      /**\n       * gets the angle in radians\n       */\n      get angle () {\n        var deltaY = lineSeg.b.y - lineSeg.a.y;\n        var deltaX = lineSeg.b.x - lineSeg.a.x;\n        return Math.atan2(deltaY, deltaX);\n      },\n      // https://stackoverflow.com/a/1968345/2066736\n      lineSegmentIntersection (lineSeg2) {\n        const [p0_x, p0_y] = [lineSeg.a.x, lineSeg.a.y];\n        const [p1_x, p1_y] = [lineSeg.b.x, lineSeg.b.y];\n        const [p2_x, p2_y] = [lineSeg2.a.x, lineSeg2.a.y];\n        const [p3_x, p3_y] = [lineSeg2.b.x, lineSeg2.b.y];\n        let s1_x, s1_y, s2_x, s2_y;\n        s1_x = p1_x - p0_x;     s1_y = p1_y - p0_y;\n        s2_x = p3_x - p2_x;     s2_y = p3_y - p2_y;\n      \n        let s, t;\n        s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);\n        t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);\n      \n        if (s >= 0 && s <= 1 && t >= 0 && t <= 1)\n        {\n          const i_x = p0_x + (t * s1_x);\n          const i_y = p0_y + (t * s1_y);\n          return Point({\n            x: i_x,\n            y: i_y,\n          })\n        }\n      \n        // No collision\n        return false; \n      },\n    };\n\n    return lineSeg;\n  }\n\n  /**\n   * \n   * @param {Point} a \n   * @param {Point} b \n   */\n  function Vector (a, b) {\n    var memo = [x,y,result];\n    const vec = {\n      point: Point(b.x - a.x, b.y - a.y),\n      get x () {\n        return this.point.x;\n      },\n      get y () {\n        return this.point.y;\n      },\n      get magnitude () {\n        if(this.x === memo[0] && this.y === memo[1]) {\n          // value has been computed\n          return memo[2];\n        } else {\n          // recompute value\n          memo = [this.x, this.y, Math.sqrt(this.x ** 2 + this.y ** 2)];\n          return memo[2]\n        }\n      },\n      dotProduct (vector) {\n        return Vector(Point(0, 0), Point(this.point.x * vector.point.x, this.point.y * vector.point.y));\n      },\n      scalarAdd (addition) {\n        return Vector(this.x+addition, this.y+addition);\n      },\n      scalarMultiply (multiplier) {\n        return Vector(this.x*multiplier, this.y*multiplier);\n      },\n      get unitVector () {\n        return  Vector(Point(0, 0), Point(this.x/this.magnitude, this.magnitude))\n      },\n\n    };\n    return vec;\n  }\n\n  function shuffle(array) {\n    let counter = array.length;\n\n    // While there are elements in the array\n    while (counter > 0) {\n      // Pick a random index\n      let index = Math.floor(Math.random() * counter);\n\n      // Decrease counter by 1\n      counter--;\n\n      // And swap the last element with it\n      let temp = array[counter];\n      array[counter] = array[index];\n      array[index] = temp;\n    }\n\n    return array;\n  }\n\n  /**\n   * \n   * @param {Point} point_a \n   * point on line\n   * @param {Point} point_b \n   * another point on line\n   */\n  function Line (point_a, point_b) {\n\n    const that = {\n      a: point_a,\n      b: point_b,\n      get A () {\n        return that.b.y - that.a.y;\n      },\n      get B () {\n        return that.a.x - that.b.x;\n      },\n      get C () {\n        return that.A * that.a.x + that.B * that.a.y\n      },\n      /**\n       * https://www.topcoder.com/community/data-science/data-science-tutorials/geometry-concepts-line-intersection-and-its-applications/\n       * @param {Line} line \n       * @returns {Point | null} \n       */\n      lineIntersection (line) {\n        const [A1, B1, C1] = [that.A, that.B, that.C]\n        const [A2, B2, C2] = [line.A, line.B, line.C];\n        const det = A1*B2 - A2*B1;\n        if(det == 0){\n            //Lines are parallel\n            return null;\n        }else{\n            return Point((B2*C1 - B1*C2)/det, \n              (A1*C2 - A2*C1)/det)\n        }\n      },\n      lineSegmentIntersection (lineSeg) {\n        return lineSegmentLineIntersection(lineSeg, that);\n      },\n      lineWithinRect (rect) {\n        var p1 = null;\n        var p2 = null;\n        var segments = shuffle([rect.boundingLeft, rect.boundingRight, rect.boundingBottom, rect.boundingTop]);\n        for(var seg of segments) {\n          let intersection = that.lineSegmentIntersection(seg);\n          if(intersection) {\n            if(p1 && !p2) {\n              p2 = intersection;\n              break;\n            }\n            if(!p1) {\n              p1 = intersection;\n            }\n          }\n        }\n        if(p1 && p2) {\n          return LineSegment(p1, p2);\n        }\n\n        return null;\n      }\n    };\n    return that;\n  }\n\n  function Ray (point, vector) {\n    return {\n      point: point,\n      vector: vector,\n    }\n  }\n\n  function Circle (spec) {\n    let that = {\n      radius: spec.radius,\n      x: spec.x,\n      y: spec.y,\n      get boundingRect () {\n        return Rectangle({\n          width: that.radius * 2,\n          height: that.radius * 2,\n          x: that.x - that.radius,\n          y: that.y - that.radius,\n        });\n      }\n    }\n\n    return that;\n  }\n\n  function Rectangle (spec) {\n    // x and y is from top left corner\n    var center = {\n      get x () {\n        return that.x + that.width / 2\n      },\n      get y () {\n        return that.y + that.height / 2;\n      },\n    };\n    var that = {\n      height: spec.height,\n      width: spec.width, \n      x: spec.x,\n      y: spec.y,\n      get top () {\n        return that.y;\n      },\n      get left () {\n        return that.x;\n      },\n      get right () {\n        return that.x + that.width;\n      },\n      get bottom () {\n        return that.y + that.height;\n      },\n      get center () {\n        return center\n      },\n      /**\n       * bounding left line segment\n       */\n      get boundingLeft () {\n        var tl = Point(that.left, that.top);\n        var bl = Point(that.left, that.bottom);\n        return LineSegment(tl, bl);\n      },\n      get boundingRight () {\n        var tr = Point(that.right, that.top);\n        var br = Point(that.right, that.bottom);\n        return LineSegment(tr, br);\n      },\n      get boundingBottom () {\n        var bl = Point(that.left, that.bottom);\n        var br = Point(that.right, that.bottom);\n        return LineSegment(bl, br);\n      },\n      get boundingTop () {\n        var tl = Point(that.left, that.top);\n        var tr = Point(that.right, that.top);\n        return LineSegment(tl, tr);\n      },\n      containsPoint (point) {\n        if(that.left <= point.x && that.right >= point.x && that.top <= point.y && that.bottom >= point.y) {\n          return true;\n        }\n        return false;\n      },\n      intersectsRect (B) {\n        // https://gamedev.stackexchange.com/a/29796\n        const A = that;\n        const w = 0.5 * (A.width + B.width);\n        const h = 0.5 * (A.height + B.height);\n        const dx = A.center.x - B.center.x;\n        const dy = A.center.y - B.center.y;\n\n        if (Math.abs(dx) <= w && Math.abs(dy) <= h)\n        {\n          /* collision! */\n          const wy = w * dy;\n          const hx = h * dx;\n\n          if (wy > hx) {\n            if (wy > -hx) {\n              /* at the bottom */\n              return Rectangle.intersectDir.bottom;\n            } else {\n                /* on the left */\n                return Rectangle.intersectDir.left;\n            }\n          }else {\n            if (wy > -hx) {\n              /* on the right */\n              return Rectangle.intersectDir.right;\n            } else {\n              /* collision at the top */\n              return Rectangle.intersectDir.top;\n            }\n          }\n        } else {\n          return false;\n        }\n      },\n      // get edges () {\n      //   return [that]\n      // },\n    };\n    \n    return that;\n  }\n  Rectangle.intersectDir = {\n    left: 'left',\n    right: 'right',\n    bottom: 'bottom',\n    top: 'top'\n  }\n\n  return {\n    Rectangle,\n    Circle,\n    LineSegment,\n    Point,\n    Line,\n  };\n})();\n"],"names":["window","Geometry","Point","x1","y1","x","y","lineSegmentLineIntersection","seg","line","inter","Line","a","b","lineIntersection","minX","Math","min","maxX","max","minY","maxY","LineSegment","point_a","point_b","lineSeg","angle","deltaY","deltaX","atan2","lineSegmentIntersection","lineSeg2","p0_x","p0_y","p1_x","p1_y","p2_x","p2_y","p3_x","p3_y","s1_x","s1_y","s2_x","s2_y","s","t","that","A","B","C","A1","B1","C1","A2","B2","C2","det","lineWithinRect","rect","p1","p2","segments","array","counter","length","index","floor","random","temp","shuffle","boundingLeft","boundingRight","boundingBottom","boundingTop","intersection","Rectangle","spec","center","width","height","top","left","right","bottom","containsPoint","point","intersectsRect","w","h","dx","dy","abs","wy","hx","intersectDir","radius","boundingRect"],"version":3,"file":"index.8d9b1fc9.js.map"}