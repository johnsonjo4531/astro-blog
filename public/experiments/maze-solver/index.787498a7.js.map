{"mappings":"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","sources":["experiments-static/maze-solver/modules/Maze.js"],"sourcesContent":["window.Maze = (function (cUtils) {\n  var oppositeDirection = {\n    'n': 's',\n    'e': 'w',\n    'w': 'e',\n    's': 'n',\n  };\n\n  function CellLink (spec = {\n    node: null,\n    direction, \n  }) {\n    var that = {};\n\n    var props = cUtils.setValues(spec);\n    cUtils.setNonConfigurable(Object.keys(spec), props);\n    Object.defineProperties(that, props);\n    var linked = false;\n    Object.defineProperties(that, {\n      isLinked: {\n        get () {\n          return linked;\n        },\n        set (val) {\n          var boolVal = !!val;\n          // set this node to linked\n          linked = boolVal;\n          // set the linked node back so it is linked to this node\n          var oppDir = oppositeDirection[that.direction];\n          if(that.node[oppDir].isLinked !== boolVal) {\n            that.node[oppDir].isLinked = boolVal;\n          }\n        },\n        configurable: true,\n      }\n    });\n\n    return that;\n  }\n\n  function linkWall (cell, wall, val) {\n    cell[wall].isLinked = !!val;\n  }\n\n  function wallExists (cell, wall) {\n    return cell[wall].isLinked;\n  }\n\n  function getLinked (cell, wall) {\n    return cell[wall].node && cell[wall].isLinked ? cell[wall].node : null;\n  }\n\n  function getUnlinked (cell, wall) {\n    return cell[wall].node && !cell[wall].isLinked ? cell[wall].node : null;\n  }\n\n  function Cell (userSpec = { }) {\n    var defaultSpec = {\n      n: CellLink({ direction: 'n' }),\n      w: CellLink({ direction: 'w' }),\n      s: CellLink({ direction: 's' }),\n      e: CellLink({ direction: 'e' }),\n      x: 0,\n      y: 0,\n    };\n    var nonOptionSpec = {\n      // computed linked neighbor properties\n      linked: {\n        get n () {\n          return getLinked(that, 'n');\n        },\n        get s () {\n          return getLinked(that, 's');\n        },\n        get e () {\n          return getLinked(that, 'e');\n        },\n        get w () {\n          return getLinked(that, 'w');\n        }\n      },\n      // computed unlinked neighbor properties\n      unlinked: {\n        get n () {\n          return getUnlinked(that, 'n');\n        },\n        get s () {\n          return getUnlinked(that, 's');\n        },\n        get e () {\n          return getUnlinked(that, 'e');\n        },\n        get w () {\n          return getUnlinked(that, 'w');\n        }\n      }\n    };\n    var spec = Object.assign({}, defaultSpec, userSpec, nonOptionSpec);\n    var that = {};\n\n    var props = cUtils.setValues(spec);\n    cUtils.setNonConfigurable([...Object.keys(defaultSpec), ...Object.keys(nonOptionSpec)], props);\n    cUtils.setNonWritable(['n', 'e', 's', 'w'], props);\n    Object.defineProperties(that, props);\n    var visited = false;\n    Object.defineProperty(that, 'visited', {\n      get () {\n        return visited;\n      }, \n      set (val) {\n        // cast to bool\n        visited = !!val;\n      }\n    });\n    return that;\n  }\n\n  /**\n   * construct a non-linked n x n maze \n   */\n  function Maze (n) {\n    var that = []; \n    for(var i = 0; i < n; ++i) {\n      that.push([]);\n      for(var j = 0; j < n; ++j) {\n        that[i].push(Cell({\n          x: j,\n          y: i,\n        }))\n      }\n    }\n\n    var empty = [];\n    for(var i = 0; i < n; ++i) {\n      for(var j = 0; j < n; ++j) {\n        // here be dragons! :P Basically it's null if i or j is out of bounds. \n        // Uses 'or' short circuiting and the fact that out of bounds elements \n        // in arrays are just undefined.\n        that[i][j].n.node = (that[i-1] || empty)[j] || null;\n        that[i][j].s.node = (that[i+1] || empty)[j] || null;\n        that[i][j].w.node = (that[i] || empty)[j-1] || null;\n        that[i][j].e.node = (that[i] || empty)[j+1] || null;\n      }\n    }\n\n    return that;\n  }\n\n  function wallString(cell,dir) {\n    return `x:${cell.x},y:${cell.y},dir:${dir}`\n  }\n\n  function getWalls (maze) {\n    var rows = maze.length;\n    var columns = maze[0].length;\n    var wallSet = new Set();\n    var walls = [];\n    for(var i = 0; i < rows; ++i) {\n      for(var j = 0; j < columns; ++j) {\n        var currNode = maze[i][j];\n        for(var [dir, neighborNode] of Object.entries(currNode.unlinked)) {\n          if(!neighborNode) {\n            continue;\n          }\n          if(dir === 'n' || dir === 'w') {\n            var id = wallString(neighborNode, oppositeDirection[dir]);\n            if(!wallSet.has(id)) {\n              walls.push([oppositeDirection[dir], neighborNode]);\n              wallSet.add(id);\n            }\n          } else {\n            var id = wallString(currNode, dir);\n            if(!wallSet.has(id)) {\n              walls.push([dir, currNode]);\n              wallSet.add(id)\n            }\n          }\n        }\n      }\n    }\n    return walls;\n  }\n\n  /**\n   * Source of this code is mdn.\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random\n   * @param {Number} min \n   * @param {Number} max \n   */\n  function getRandomInt(min, max) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    // The maximum is exclusive and the minimum is inclusive\n    return Math.floor(Math.random() * (max - min)) + min; \n  }\n\n  function randomItemArr (arr) {\n    var randIdx = getRandomInt(0, arr.length);\n    return arr[randIdx];\n  }\n\n  function randomItemSet (set) {\n    var arr = [...set];\n    return randomItemArr(arr);\n  }\n\n  function randomItem2dArr (arr) {\n    var randIdxRow = getRandomInt(0, arr.length);\n    var randIdxCol = getRandomInt(0, arr[0].length);\n    return arr[randIdxRow][randIdxCol];\n  }\n\n  function getNewFrontiers (newMazeItem, frontier, linkedMaze) {\n    for(var node of Object.values(newMazeItem.unlinked)) {\n      if(node && !linkedMaze.has(node)) {\n        frontier.add(node);\n      } \n    }\n  }\n\n  /**\n   * Generates a maze using Prim's algorithm.\n   * @param {Number} n \n   * the dimensions of the n x n maze.\n   */\n  function generateMaze (n) {\n    var maze = Maze(n);\n    var cols = maze[0].length;\n    var rows = maze.length;\n    var mazeSize = rows * cols;\n    var frontier = new Set();\n    var linkedMaze = new Set();\n\n    var newMazeItem = randomItem2dArr(maze);\n    linkedMaze.add(newMazeItem);\n    getNewFrontiers(newMazeItem, frontier, linkedMaze);\n\n    // run until the maze is all linked\n    while(frontier.size > 0) {\n      var newMazeItem = randomItemSet(frontier);\n      linkedMaze.add(newMazeItem);\n      frontier.delete(newMazeItem);\n      // get all wall directions adjacent to linkedMaze\n      var adjWallDirs = [];\n      for(var [dir, neighborNode] of Object.entries(newMazeItem.unlinked)) {\n        if(!!neighborNode && linkedMaze.has(neighborNode)) {\n          adjWallDirs.push(dir);\n        }\n      }\n      // randomly pick an adjacent wall and link it\n      var randomAdjDir = randomItemArr(adjWallDirs);\n      newMazeItem[randomAdjDir].isLinked = true;\n      getNewFrontiers(newMazeItem, frontier, linkedMaze);\n    }\n\n    return {\n      matrix: maze,\n      walls: getWalls(maze),\n    };\n  }\n\n  return {\n    generate: generateMaze,\n  };\n})(ClassUtils);\n"],"names":["window","Maze","cUtils","oppositeDirection","n","e","w","s","CellLink","spec","node","direction","that","props","setValues","setNonConfigurable","Object","keys","defineProperties","linked","isLinked","get","set","val","boolVal","oppDir","configurable","getLinked","cell","wall","getUnlinked","Cell","userSpec","defaultSpec","x","y","nonOptionSpec","unlinked","assign","setNonWritable","visited","defineProperty","wallString","dir","getWalls","maze","rows","length","columns","wallSet","Set","walls","i","j","currNode","neighborNode","entries","id","has","push","add","getRandomInt","min","max","Math","ceil","floor","random","randomItemArr","arr","getNewFrontiers","newMazeItem","frontier","linkedMaze","values","generate","randIdxRow","randIdxCol","empty","size","delete","adjWallDirs","matrix","ClassUtils"],"version":3,"file":"index.787498a7.js.map"}